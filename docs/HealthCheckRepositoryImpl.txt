package repository.impl;

import config.Environment;
import dto.GatewayHealth;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.redis.client.Command;
import io.vertx.redis.client.Redis;
import io.vertx.redis.client.Request;
import repository.IHealthCheckRepository;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import static config.Constants.*;

/**
 * Implementação do repositório de health check utilizando Redis.
 */
public class HealthCheckRepositoryImpl implements IHealthCheckRepository {

    private static final Logger logger = Logger.getLogger(HealthCheckRepositoryImpl.class.getName());
    private final Redis redis;

    /**
     * Construtor que inicializa o cliente Redis.
     *
     * @param vertx Instância do Vertx.
     */
    public HealthCheckRepositoryImpl(Vertx vertx) {
        this.redis = RedisClientProvider.getInstance(vertx);
    }

    /**
     * Salva o status de health check no Redis.
     *
     * @param key    Chave do registro.
     * @param health Dados de health check.
     * @return Future indicando sucesso ou falha.
     */
    @Override
    public Future<Void> saveHealth(String key, GatewayHealth health) {
        Promise<Void> promise = Promise.promise();

        this.redis.send(Request.cmd(Command.HSET)
                        .arg(key)
                        .arg(MSG_GATEWAY_HEALTH_FAILING).arg(String.valueOf(health.failing()))
                        .arg(MSG_GATEWAY_HEALTH_MINRESPONSE_TIME).arg(String.valueOf(health.minResponseTime()))
                        .arg(MSG_GATEWAY_LAST_HEALTH_CHECK).arg(String.valueOf(health.lastChecked().toEpochMilli())),
                res -> {
                    if (res.succeeded()) {
                        promise.complete();
                    } else {
                        Environment.processLogging(
                                logger,
                                "Falha ao salvar health check no Redis: " + res.cause().getMessage()
                        );
                        promise.fail(res.cause());
                    }
                });
        return promise.future();
    }

    /**
     * Recupera o status de health check do Redis.
     *
     * @param key Chave do registro.
     * @return Future com os dados de health check ou null se não encontrado.
     */
    @Override
    public Future<GatewayHealth> getHealth(String key) {
        Promise<GatewayHealth> promise = Promise.promise();

        try {
            redis.send(Request.cmd(Command.HGETALL).arg(key))
                    .onSuccess(response -> {
                        try {
                            if (response != null && response.size() > 0) {
                                Map<String, String> healthData = response.getKeys().stream()
                                        .collect(HashMap::new,
                                                (map, key1) -> map.put(key1, response.get(key1).toString()),
                                                HashMap::putAll);

                                // Valida se os campos obrigatórios existem
                                if (!healthData.containsKey(MSG_GATEWAY_HEALTH_FAILING) ||
                                        !healthData.containsKey(MSG_GATEWAY_HEALTH_MINRESPONSE_TIME) ||
                                        !healthData.containsKey(MSG_GATEWAY_LAST_HEALTH_CHECK)) {
                                    promise.complete(null);
                                    return;
                                }

                                boolean failing = Boolean.parseBoolean(healthData.get(MSG_GATEWAY_HEALTH_FAILING));
                                long minResponseTime = Long.parseLong(healthData.get(MSG_GATEWAY_HEALTH_MINRESPONSE_TIME));
                                Instant lastChecked = Instant.ofEpochMilli(Long.parseLong(healthData.get(MSG_GATEWAY_LAST_HEALTH_CHECK)));

                                promise.complete(new GatewayHealth(failing, minResponseTime, lastChecked));
                            } else {
                                promise.complete(null);
                            }
                        } catch (Exception e) {
                            Environment.processLogging(
                                    logger,
                                    "Erro ao processar resposta do Redis para a chave " + key + ": " + e.getMessage()
                            );
                            promise.fail(e);
                        }
                    })
                    .onFailure(ex -> {
                        Environment.processLogging(
                                logger,
                                "Falha no Redis HGETALL para a chave " + key + ": " + ex.getMessage()
                        );
                        promise.fail(ex);
                    });
        } catch (Exception e) {
            Environment.processLogging(
                    logger,
                    "Erro no método getHealth para a chave " + key + ": " + e.getMessage()
            );
            promise.fail(e);
        }

        return promise.future();
    }
}
