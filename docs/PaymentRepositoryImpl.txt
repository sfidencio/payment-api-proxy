package repository.impl;

import config.RedisClientProvider;
import dto.PaymentSummary;
import dto.PaymentSummaryByGatewayResponse;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.impl.future.CompositeFutureImpl;
import io.vertx.redis.client.Redis;
import io.vertx.redis.client.RedisAPI;
import repository.IPaymentRepository;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.Instant;
import java.util.*;

import static config.Constants.PROCESSOR_GATEWAY_SELECTED_DEFAULT;
import static config.Constants.PROCESSOR_GATEWAY_SELECTED_FALLBACK;


public class PaymentRepositoryImpl implements IPaymentRepository {


    private final RedisAPI redisAPI;

    public PaymentRepositoryImpl(Vertx vertx) {
        Redis redisClient = RedisClientProvider.getInstance(vertx);
        this.redisAPI = RedisAPI.api(redisClient);
    }


//    @Override
//    public Future<Void> save(String correlationId,
//                             String gatewayType,
//                             long amountInCents) {
//        String key = "payments:".concat(gatewayType);
//        String value = String.format("%s:%s", correlationId, amountInCents);
//        long score = Instant.now().toEpochMilli();
//
//        Promise<Void> promise = Promise.promise();
//
//        this.redisAPI.zadd(
//                Arrays.asList(
//                        key,
//                        String.valueOf(score),
//                        value
//                )
//        ).compose(
//                res ->
//                        redisAPI.hset(
//                                Arrays.asList(
//                                        "payments-query:index",
//                                        correlationId,
//                                        String.format("%s", correlationId)
//                                )
//                        )
//
//        ).onSuccess(
//                r -> promise.complete()
//        ).onFailure(promise::fail);
//
//        return promise.future();
//    }

    @Override
    public Future<Void> save(String correlationId,
                             String gatewayType,
                             long amountInCents,
                             Instant timestamp) {
        String key = "payments:".concat(gatewayType).concat(":").concat(correlationId).concat(":").concat(String.valueOf(amountInCents));
        String value = String.valueOf(amountInCents).concat(":").concat(String.valueOf(timestamp.toEpochMilli()));

        Promise<Void> promise = Promise.promise();

        this.redisAPI.setnx(key, value)
                .onSuccess(res -> {
                    if (res != null && "1".equals(res.toString())) {
                        promise.complete();
                    } else {
                        promise.fail("Duplicate correlationId for this gateway");
                    }
                })
                .onFailure(promise::fail);

        return promise.future();
    }

    @Override
    public Future<Boolean> getByCorrelationId(String correlationId) {
//        return this.redisAPI.hget(
//                        "payments-query:index",
//                        correlationId
//                )
//                .map(res -> res != null && res.toString().trim().equals(correlationId.trim()));
        // SETNX returns 1 if the key was set, 0 if it already exists
        return this.redisAPI.setnx("payments-query:index:" + correlationId, "1")
                .map(res -> res != null && "1".equals(res.toString()));
    }


//    public Future<PaymentSummaryByGatewayResponse> get(Instant from, Instant to) {
//        Promise<PaymentSummaryByGatewayResponse> promise = Promise.promise();
//        this.redisAPI.keys("payments:*").onComplete(keysRes -> {
//            if (keysRes.failed()) {
//                promise.fail(keysRes.cause());
//                return;
//            }
//            String[] keys = keysRes.result().stream()
//                    .map(Object::toString)
//                    .toArray(String[]::new);
//            Map<String, PaymentSummary> tempMap = new LinkedHashMap<>();
//            long fromM = from == null ? 0L : from.toEpochMilli();
//            long toM = to == null ? Long.MAX_VALUE : to.toEpochMilli();
//
//            List<Future> futures = new ArrayList<>();
//
//            for (String key : keys) {
//                String gateway = key.replace("payments:", "");
//                Future<List<String>> entries = this.redisAPI.zrangebyscore(
//                        Arrays.asList(
//                                key,
//                                String.valueOf(fromM),
//                                String.valueOf(toM)
//                        )
//                ).map(entriesMap -> entriesMap.stream().map(Object::toString).toList());
//
//                futures.add(entries.onSuccess(entriesFuture -> {
//                    long totalAmountInCents = entriesFuture.stream()
//                            .mapToLong(entry -> Long.parseLong(entry.split(":")[1]))
//                            .sum();
//                    double totalFormatted = BigDecimal.valueOf(totalAmountInCents).movePointLeft(2)
//                            .setScale(2, RoundingMode.HALF_UP).doubleValue();
//
//                    tempMap.put(gateway, new PaymentSummary(
//                            entriesFuture.size(),
//                            totalFormatted
//                    ));
//                }));
//            }
//
//            CompositeFutureImpl.all(
//                    futures.toArray(
//                            new Future[0]
//                    )
//            ).onComplete(
//                    ar -> {
//                        if (ar.succeeded()) {
//                            Map<String, PaymentSummary> summaryByGateway = new LinkedHashMap<>();
//                            summaryByGateway.put(PROCESSOR_GATEWAY_SELECTED_DEFAULT, new PaymentSummary(0, 0.0));
//                            summaryByGateway.put(PROCESSOR_GATEWAY_SELECTED_FALLBACK, new PaymentSummary(0, 0.0));
//
//                            if (tempMap.containsKey("default")) {
//                                summaryByGateway.put("default", tempMap.get("default"));
//                            }
//                            tempMap.keySet().stream()
//                                    .filter(gateway -> !gateway.equals("default"))
//                                    .sorted()
//                                    .forEach(gateway -> summaryByGateway.put(gateway, tempMap.get(gateway)));
//
//                            promise.complete(new PaymentSummaryByGatewayResponse(summaryByGateway));
//                        } else {
//                            promise.fail(ar.cause());
//                        }
//                    });
//
//        });
//
//        return promise.future();
//    }

    public Future<PaymentSummaryByGatewayResponse> get(Instant from, Instant to) {
        Promise<PaymentSummaryByGatewayResponse> promise = Promise.promise();
        this.redisAPI.keys("payments:*:*").onComplete(keysRes -> {
            if (keysRes.failed()) {
                promise.fail(keysRes.cause());
                return;
            }
            List<String> keys = keysRes.result().stream().map(Object::toString).toList();
            Map<String, PaymentSummary> tempMap = new LinkedHashMap<>();
            long fromM = from == null ? 0L : from.toEpochMilli();
            long toM = to == null ? Long.MAX_VALUE : to.toEpochMilli();

            List<Future> futures = new ArrayList<>();
            for (String key : keys) {
                futures.add(this.redisAPI.get(key).map(value -> {
                    if (value == null) return null;
                    String[] parts = value.toString().split(":");
                    if (parts.length != 2) return null;
                    long amount = Long.parseLong(parts[0]);
                    long ts = Long.parseLong(parts[1]);
                    if (ts >= fromM && ts <= toM) {
                        String gateway = key.split(":")[1];
                        return Map.entry(gateway, amount);
                    }
                    return null;
                }));
            }

            CompositeFutureImpl.all(futures.toArray(new Future[0])).onComplete(ar -> {
                if (ar.succeeded()) {
                    Map<String, List<Long>> grouped = new HashMap<>();
                    for (int i = 0; i < ar.result().size(); i++) {
                        var entry = (Map.Entry<String, Long>) ar.result().resultAt(i);
                        if (entry != null) {
                            grouped.computeIfAbsent(entry.getKey(), k -> new ArrayList<>()).add(entry.getValue());
                        }
                    }
                    for (var e : grouped.entrySet()) {
                        long totalAmount = e.getValue().stream().mapToLong(Long::longValue).sum();
                        double totalFormatted = BigDecimal.valueOf(totalAmount).movePointLeft(2)
                                .setScale(2, RoundingMode.HALF_UP).doubleValue();
                        tempMap.put(e.getKey(), new PaymentSummary(e.getValue().size(), totalFormatted));
                    }

                    Map<String, PaymentSummary> summaryByGateway = new LinkedHashMap<>();
                    summaryByGateway.put(PROCESSOR_GATEWAY_SELECTED_DEFAULT, new PaymentSummary(0, 0.0));
                    summaryByGateway.put(PROCESSOR_GATEWAY_SELECTED_FALLBACK, new PaymentSummary(0, 0.0));
                    if (tempMap.containsKey("default")) {
                        summaryByGateway.put("default", tempMap.get("default"));
                    }
                    tempMap.keySet().stream()
                            .filter(gw -> !gw.equals("default"))
                            .sorted()
                            .forEach(gw -> summaryByGateway.put(gw, tempMap.get(gw)));

                    promise.complete(new PaymentSummaryByGatewayResponse(summaryByGateway));
                } else {
                    promise.fail(ar.cause());
                }
            });
        });
        return promise.future();
    }

}