package repository.impl;

import config.Environment;
import config.RedisClientProvider;
import dto.PaymentMessage;
import dto.PaymentRequest;
import dto.PaymentSummary;
import dto.PaymentSummaryByGatewayResponse;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.impl.future.CompositeFutureImpl;
import io.vertx.redis.client.Redis;
import io.vertx.redis.client.RedisAPI;
import io.vertx.redis.client.Response;
import io.vertx.redis.client.ResponseType;
import repository.IPaymentRepository;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.Instant;
import java.util.*;
import java.util.logging.Logger;

import static config.Constants.PROCESSOR_GATEWAY_SELECTED_DEFAULT;
import static config.Constants.PROCESSOR_GATEWAY_SELECTED_FALLBACK;


/**
 * Implementação do repositório de pagamentos utilizando Redis como backend.
 * <p>
 * Esta classe é responsável por todas as operações de persistência, consumo e confirmação de mensagens de pagamento,
 * além de fornecer métodos para sumarização de dados de pagamentos agrupados por gateway.
 * </p>
 *
 * <p>
 * Principais responsabilidades:
 * <ul>
 *   <li>Gerenciar a fila de pagamentos (Redis Stream) para enfileirar, consumir e confirmar mensagens.</li>
 *   <li>Criar e gerenciar grupos de consumidores para processamento concorrente e seguro das mensagens.</li>
 *   <li>Persistir e recuperar informações de pagamentos processados.</li>
 *   <li>Fornecer sumarização de pagamentos por gateway e período.</li>
 * </ul>
 * </p>
 *
 * <p>
 * Funcionamento geral:
 * <ol>
 *   <li>Ao instanciar, garante a existência do grupo de consumidores no Redis Stream.</li>
 *   <li>Permite enfileirar novas requisições de pagamento na fila.</li>
 *   <li>Consome lotes de mensagens pendentes para processamento, respeitando o grupo e consumidor.</li>
 *   <li>Confirma (acknowledge) mensagens processadas para evitar reprocessamento.</li>
 *   <li>Permite sumarizar pagamentos processados por gateway em determinado período.</li>
 * </ol>
 * </p>
 *
 * <p>
 * Detalhes dos principais campos:
 * <ul>
 *   <li><b>PAYMENT_QUEUE</b>: Nome da stream Redis utilizada como fila de pagamentos.</li>
 *   <li><b>CONSUMER_GROUP</b>: Nome do grupo de consumidores para processamento concorrente.</li>
 *   <li><b>CONSUMER_NAME</b>: Identificador do consumidor atual.</li>
 *   <li><b>redisAPI</b>: Instância da API do Redis para execução dos comandos.</li>
 * </ul>
 * </p>
 *
 * <p>
 * Observações:
 * <ul>
 *   <li>Utiliza o padrão de stream do Redis para garantir processamento escalável e seguro.</li>
 *   <li>Mensagens só são removidas da fila após confirmação explícita (ack).</li>
 *   <li>Falhas na criação do grupo de consumidores são tratadas como já existente.</li>
 * </ul>
 * </p>
 *
 * @author Seu Nome
 * @since 1.0
 */
public class PaymentRepositoryImpl implements IPaymentRepository {

    private static final String PAYMENT_QUEUE = "payments:stream";
    private static final String CONSUMER_GROUP = "payment-consumers";
    private static final Logger logger = Logger.getLogger(PaymentRepositoryImpl.class.getName());


    private final RedisAPI redisAPI;

    public PaymentRepositoryImpl(Vertx vertx) {
        Redis redisClient = RedisClientProvider.getInstance(vertx);
        this.redisAPI = RedisAPI.api(redisClient);
        ensureConsumerGroupExists();
    }

    @Override
    public Future<String> save(PaymentRequest request) {
        Promise<String> promise = Promise.promise();
        String correlationKey = "payments:correlationIds";

        // Try to add the correlationId to a Redis SET (returns 1 if new, 0 if already exists)
        this.redisAPI.sadd(Arrays.asList(correlationKey, request.getCorrelationId()))
                .onSuccess(res -> {
                    if ("1".equals(res.toString())) {
                        // Not a duplicate, proceed to add to stream
                        List<String> streamArgs = Arrays.asList(
                                PAYMENT_QUEUE, "*",
                                "correlationId", request.getCorrelationId(),
                                "amountInCents", String.valueOf(request.getAmountInCents()),
                                "timestampMs", String.valueOf(request.getRequestAt().toEpochMilli())
                        );
                        this.redisAPI.xadd(streamArgs)
                                .onSuccess(r -> promise.complete(r.toString()))
                                .onFailure(promise::fail);
                    } else {
                        // Duplicate found
                        promise.fail("Duplicate correlationId: " + request.getCorrelationId());
                    }
                })
                .onFailure(promise::fail);

        return promise.future();
    }


    public Future<String> enqueue(PaymentRequest request) {
        Promise<String> promise = Promise.promise();
        List<String> args = Arrays.asList(
                PAYMENT_QUEUE, "*",
                "correlationId", request.getCorrelationId(),
                "amountInCents", String.valueOf(request.getAmountInCents()),
                "timestampMs", String.valueOf(request.getRequestAt().toEpochMilli())
        );

        this.redisAPI.xadd(args)
                .onSuccess(res -> promise.complete(res.toString()))
                .onFailure(promise::fail);

        return promise.future();
    }

    @Override
    public Future<Boolean> checkDuplicateCorrelationId(String correlationId) {
        Promise<Boolean> promise = Promise.promise();
        String correlationKey = "payments:correlationIds";

        this.redisAPI.send("SISMEMBER", correlationKey, correlationId))
                .onSuccess(res -> {
                    // Redis SISMEMBER retorna 1 se existe, 0 se não existe
                    boolean isDuplicate = "1".equals(res.toString());
                    promise.complete(isDuplicate);
                })
                .onFailure(err -> {
                    Environment.processLogging(logger, "Erro ao verificar duplicidade: " + err.getMessage());
                    promise.fail(err);
                });

        return promise.future();
    }


    public Future<List<PaymentMessage>> consumeBatch(int count, String consumerName) {
        Promise<List<PaymentMessage>> promise = Promise.promise();
        List<String> args = Arrays.asList(
                "GROUP", CONSUMER_GROUP, consumerName,
                "COUNT", String.valueOf(count),
                "BLOCK", "2000",
                "STREAMS", PAYMENT_QUEUE, ">"
        );

        this.redisAPI.xreadgroup(args).onSuccess(res -> {
            List<PaymentMessage> messages = new ArrayList<>();
            if (res != null && res.type() == ResponseType.MULTI && res.size() > 0) {
                for (String streamKey : res.getKeys()) {
                    Response stream = res.get(streamKey);
                    if (stream != null && stream.type() == ResponseType.MULTI && stream.size() > 0) {
                        List<Response> entries = stream.stream().toList();
                        for (Response entry : entries) {
                            if (entry != null && entry.type() == ResponseType.MULTI && entry.size() > 1) {
                                String messageId = entry.get(0).toString();
                                List<Response> fields = entry.get(1).stream().toList();
                                Map<String, String> req = new HashMap<>();
                                for (int j = 0; j < fields.size(); j += 2) {
                                    String key = fields.get(j).toString();
                                    String value = fields.get(j + 1).toString();
                                    req.put(key, value);
                                }
                                PaymentRequest paymentRequest = new PaymentRequest(
                                        req.get("correlationId"),
                                        req.get("amountInCents") != null ? Long.parseLong(req.get("amountInCents")) : 0L
                                );
                                paymentRequest.setRequestAt(
                                        Instant.ofEpochMilli(Long.parseLong(req.get("timestampMs")))
                                );
                                messages.add(new PaymentMessage(messageId, paymentRequest));
                            }
                        }
                    }
                }
            }
            promise.complete(messages);
        }).onFailure(promise::fail);
        return promise.future();
    }


    public Future<Void> ack(String messageId) {
        Promise<Void> promise = Promise.promise();
        this.redisAPI.xack(Arrays.asList(PAYMENT_QUEUE, CONSUMER_GROUP, messageId)).onSuccess(res -> promise.complete(null))
                .onFailure(promise::fail);
        return promise.future();
    }

    public Future<PaymentSummaryByGatewayResponse> get(Instant from, Instant to) {
        Promise<PaymentSummaryByGatewayResponse> promise = Promise.promise();
        List<String> gateways = List.of(PROCESSOR_GATEWAY_SELECTED_DEFAULT, PROCESSOR_GATEWAY_SELECTED_FALLBACK);

        long fromM = from == null ? 0L : from.toEpochMilli();
        long toM = to == null ? Long.MAX_VALUE : to.toEpochMilli();

        List<Future> futures = new ArrayList<>();
        for (String gateway : gateways) {
            String zsetKey = "payments:" + gateway;
            futures.add(this.redisAPI.zrangebyscore(Arrays.asList(zsetKey, String.valueOf(fromM), String.valueOf(toM))));
        }

        CompositeFutureImpl.all(futures.toArray(new Future[0])).onComplete(ar -> {
            if (ar.succeeded()) {
                Map<String, PaymentSummary> summaryByGateway = new LinkedHashMap<>();
                for (int i = 0; i < gateways.size(); i++) {
                    String gateway = gateways.get(i);
                    // Use Response type, not List
                    Response response = ar.result().resultAt(i);
                    long totalAmount = 0;
                    int count = 0;
                    if (response != null && response.size() > 0) {
                        for (int j = 0; j < response.size(); j++) {
                            String member = response.get(j).toString();
                            String[] parts = member.split(":");
                            if (parts.length >= 1) {
                                totalAmount += Long.parseLong(parts[0]);
                                count++;
                            }
                        }
                    }
                    double totalFormatted = BigDecimal.valueOf(totalAmount).movePointLeft(2)
                            .setScale(2, RoundingMode.HALF_UP).doubleValue();
                    summaryByGateway.put(gateway, new PaymentSummary(count, totalFormatted));
                }
                promise.complete(new PaymentSummaryByGatewayResponse(summaryByGateway));
            } else {
                promise.fail(ar.cause());
            }
        });
        return promise.future();
    }

    private void ensureConsumerGroupExists() {
        this.redisAPI.xreadgroup(Arrays.asList(PAYMENT_QUEUE)).onComplete(groupsRes -> {
            boolean groupExists = false;
            if (groupsRes.succeeded() && groupsRes.result() != null) {
                for (var groupInfo : groupsRes.result()) {
                    if (groupInfo != null && groupInfo.toString().contains(CONSUMER_GROUP)) {
                        groupExists = true;
                        break;
                    }
                }
            }
            if (!groupExists) {
                this.redisAPI.xgroup(Arrays.asList(
                        "CREATE", PAYMENT_QUEUE, CONSUMER_GROUP, "$", "MKSTREAM"
                )).onComplete(res -> {
                    if (res.succeeded()) {
                        Environment.processLogging(
                                logger,
                                "Consumer group created successfully: " + CONSUMER_GROUP
                        );
                    } else {
                        Environment.processLogging(
                                logger,
                                "Failed to create consumer group: " + CONSUMER_GROUP + ", Error: " + res.cause().getMessage()
                        );
                    }
                });
            } else {
                Environment.processLogging(
                        logger,
                        "Consumer group already exists: " + CONSUMER_GROUP
                );
            }
        });
    }

}