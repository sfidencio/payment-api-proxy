package handler;

import config.Environment;
import dto.PaymentRequest;
import io.vertx.core.Vertx;
import io.vertx.ext.web.RoutingContext;
import org.json.JSONObject;

import java.util.logging.Logger;

public class PaymentHandler implements io.vertx.core.Handler<RoutingContext> {
    private static final Logger logger = Logger.getLogger(PaymentHandler.class.getName());

    /**
     * Handles incoming payment processing requests.
     * <p>
     * This handler is partially asynchronous: reading the HTTP request body and responding to the client
     * are non-blocking and run on the Vert.x event loop. However, the actual payment processing logic,
     * including calls to the service layer, Redis, and external HTTP services, uses synchronous Java APIs.
     * These operations are executed inside {@code vertx.executeBlocking}, which offloads them to a worker thread
     * to avoid blocking the event loop. As a result, the overall flow is not fully reactive or asynchronous.
     * For true async behavior, the service and dependencies should use Vert.x's non-blocking clients and return {@code Future} or {@code Promise}.
     * </p>
     *
     * @param ctx the {@link io.vertx.ext.web.RoutingContext} containing the HTTP request and response
     * @return void
     * @throws Exception if an error occurs during payment processing
     * @see service.PaymentServiceImpl
     */
    @Override
    public void handle(RoutingContext ctx) {
        Environment.processLogging(
                logger,
                "Received payment processing request"
        );
        ctx.request().body().onComplete(ar -> {
            if (ar.succeeded()) {
                Vertx vertx = ctx.vertx();
                vertx.executeBlocking(promisse -> {
                    try {


                        var json = new JSONObject(ar.result().toString());
                        var request = new PaymentRequest(
                                json.getString("correlationId"),
                                json.getLong("amount")
                        );
                        boolean success = service.PaymentServiceImpl.processPayment(request);
                        promisse.complete();
                    } catch (Exception ex) {
                        Environment.processLogging(
                                logger,
                                "Failed to process payment request: " + ex.getMessage()
                        );
                        promisse.fail(ex);
                    }
                }, res -> {
                    if (res.succeeded()) {
                        boolean success = (Boolean) res.result();
                        Environment.processLogging(
                                logger,
                                "Payment processing completed successfully: " + success
                        );
                        ctx.response().setStatusCode(success ? 200 : 502)
                                .end(success ? "Payment processed successfully" : "Payment processing failed");
                    } else {
                        Environment.processLogging(
                                logger,
                                "Payment processing failed: " + res.cause().getMessage()
                        );
                        ctx.response().setStatusCode(400)
                                .end("Invalid request body");
                    }

                });
            } else {
                ctx.response().setStatusCode(400).end("Invalid request body");
                Environment.processLogging(
                        logger,
                        "Failed to process payment request: " + ar.cause().getMessage()
                );
            }
        });
    }
}
